package inspector.jmondb.model;

/*
 * #%L
 * jMonDB Core
 * %%
 * Copyright (C) 2014 InSPECtor
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.Hibernate;
import org.hibernate.proxy.HibernateProxyHelper;

import javax.persistence.*;
import java.sql.Timestamp;
import java.util.*;

/**
 * A {@code Run} represents a single experimental run (signified by a single raw file), and can contain several {@link Value}s.
 */
@Entity
@Access(AccessType.FIELD)
@Table(name="imon_run", uniqueConstraints=@UniqueConstraint(columnNames={"l_imon_instrument_id", "name"}))
public class Run {

    @Transient
    private static final Logger LOGGER = LogManager.getLogger(Run.class);

    /** read-only iMonDB primary key; generated by JPA */
    @Id
    @Column(name="id", nullable=false)
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

    /** the name identifying the run */
    @Column(name="name", nullable=false, length=100)
    private String name;
    /** the location of the raw data belonging to the run */
    @Column(name="storage_name", nullable=false, length=255)
    private String storageName;
    /** the date on which the run was performed */
    @Column(name="sampledate", nullable=false)
    private Timestamp sampleDate;

    /** additional {@link Metadata} describing the run */
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="run")
    @MapKey(name="name")
    private Map<String, Metadata> metadata;

    /** all {@link Value}s for the run */
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY, mappedBy="originatingRun")
    @MapKeyJoinColumn(name="l_imon_property_id", referencedColumnName="id")
    @MapKeyClass(Property.class)
    private Map<Property, Value> runValues;

    /** inverse part of the bi-directional relationship with {@link Instrument} */
    @ManyToOne(cascade={CascadeType.PERSIST, CascadeType.MERGE}, fetch=FetchType.LAZY)
    @JoinColumn(name="l_imon_instrument_id", nullable=false, referencedColumnName="id")
    private Instrument instrument;

    /** a sensible default capacity to reduce rehashing */
    private static final int DEFAULT_RUN_CAPACITY = 512;

    /**
     * Default constructor required by JPA.
     * Protected access modification to enforce that client code uses the constructor that sets the required member variables.
     */
    protected Run() {
        metadata = new HashMap<>();
        runValues = new HashMap<>(DEFAULT_RUN_CAPACITY);
    }

    /**
     * Creates a {@code Run} representing a specific experiment.
     *
     * @param name  the name identifying the run, not {@code null}
     * @param storageName  the location of the raw data belonging to the run, not {@code null}
     * @param sampleDate  the date on which the run was performed, not {@code null}
     * @param instrument  the {@link Instrument} on which the run was executed, not {@code null}
     */
    public Run(String name, String storageName, Timestamp sampleDate, Instrument instrument) {
        this();

        setName(name);
        setStorageName(storageName);
        setSampleDate(sampleDate);
        setInstrument(instrument);
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    private void setName(String name) {
        if(name != null) {
            this.name = name;
        } else {
            LOGGER.error("The run's name is not allowed to be <null>");
            throw new NullPointerException("The run's name is not allowed to be <null>");
        }
    }

    public String getStorageName() {
        return storageName;
    }

    private void setStorageName(String storageName) {
        if(storageName != null) {
            this.storageName = storageName;
        } else {
            LOGGER.error("The run's storage name is not allowed to be <null>");
            throw new NullPointerException("The run's storage name is not allowed to be <null>");
        }
    }

    public Timestamp getSampleDate() {
        return new Timestamp(sampleDate.getTime());
    }

    private void setSampleDate(Timestamp sampleDate) {
        if(sampleDate != null) {
            this.sampleDate = sampleDate;
        } else {
            LOGGER.error("The run's sample date is not allowed to be <null>");
            throw new NullPointerException("The run's sample date is not allowed to be <null>");
        }
    }

    public Instrument getInstrument() {
        return instrument;
    }

    private void setInstrument(Instrument instrument) {
        if(instrument != null) {
            this.instrument = instrument;
            instrument.addRun(this);
        } else {
            LOGGER.error("The run's instrument is not allowed to be <null>");
            throw new NullPointerException("The run's instrument is not allowed to be <null>");
        }
    }

    /**
     * Returns the {@link Value} that originates from this {@code Run} and that is defined by the given {@link Property}.
     *
     * @param property  the {@code Property} that defines the requested {@code Value}, {@code null} returns {@code null}
     * @return the {@code Value} that originates from this {@code Run} and that is defined by the given {@link Property} if it exists, {@code null} otherwise
     */
    public Value getValue(Property property) {
        return property != null && Hibernate.isInitialized(runValues) ? runValues.get(property) : null;
    }

    /**
     * Returns an {@link Iterator} over all {@link Value}s that originate from this {@code Run}.
     *
     * @return an {@code Iterator} over all {@code Value}s that originate from this {@code Run}
     */
    public Iterator<Value> getValueIterator() {
        return Hibernate.isInitialized(runValues) ? runValues.values().iterator() : Collections.emptyIterator();
    }

    /**
     * Adds the given {@link Value} to this {@code Run}.
     *
     * If the {@code Run} previously contained a {@code Value} associated with the same {@link Property}, the old {@code Value} is replaced.
     *
     * A {@code Value} is automatically added to its {@code Run} upon its instantiation.
     *
     * @param value  the {@code Value} that is added to this {@code Run}, not {@code null}
     */
    void addValue(Value value) {
        if(value != null) {
            if(!Hibernate.isInitialized(runValues)) {
                runValues = new HashMap<>(DEFAULT_RUN_CAPACITY);
            }
            // add the value to the run (existing values will be overwritten)
            runValues.put(value.getDefiningProperty(), value);
            // add the value's defining property to the instrument
            instrument.assignProperty(value.getDefiningProperty());
        } else {
            LOGGER.error("Can't add a <null> value to the run");
            throw new NullPointerException("Can't add a <null> value to the run");
        }
    }

    /**
     * Returns the {@link Metadata} for this {@code Run} with the given name.
     *
     * @param name  the name of the requested {@code Metadata}, {@code null} returns {@code null}
     * @return the {@code Metadata} for this {@code Run} with the given name if it exists, {@code null} otherwise
     */
    public Metadata getMetadata(String name) {
        return name != null ? metadata.get(name) : null;
    }

    /**
     * Returns an {@link Iterator} over all {@link Metadata} for this {@code Run}.
     *
     * @return an {@code Iterator} over all {@code Metadata} for this {@code Run}
     */
    public Iterator<Metadata> getMetadataIterator() {
        return metadata.values().iterator();
    }

    /**
     * Assigns the given {@link Metadata} to this {@code Run}.
     *
     * If the {@code Run} previously contained a {@code Metadata} with the same name, the old {@code Metadata} is replaced.
     *
     * {@code Metadata} is automatically added to its {@code Run} upon its instantiation.
     *
     * @param meta  the {@code Metadata} that is assigned to this {@code Run}, not {@code null}
     */
    void addMetadata(Metadata meta) {
        if(meta != null) {
            metadata.put(meta.getName(), meta);
        } else {
            LOGGER.error("Can't add <null> metadata to the run");
            throw new NullPointerException("Can't add <null> metadata to the run");
        }
    }

    /**
     * Explicitly initializes containers that are loaded lazily.
     *
     * Initializing the containers is only possible if the {@code Run} is still attached to the JPA session that was used to retrieve it from a database.
     * Otherwise, this method has no effect.
     */
    public void initializeContainers() {
        runValues.size();
    }

    @Override
    public boolean equals(Object o) {
        if(this == o) {
            return true;
        }
        if(o == null || getClass() != HibernateProxyHelper.getClassWithoutInitializingProxy(o)) {
            return false;
        }

        final Run run = (Run) o;
        return	   Objects.equals(name, run.getName())
                && Objects.equals(storageName, run.getStorageName())
                && Objects.equals(sampleDate, run.getSampleDate())
                && Objects.equals(instrument, run.getInstrument());
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, storageName, sampleDate, instrument);
    }

    @Override
    public String toString() {
        return "Run {id=" + id + ", name=" + name + ", instrument=" + instrument.getName() + ", #values=" + runValues.size() + "}";
    }
}
