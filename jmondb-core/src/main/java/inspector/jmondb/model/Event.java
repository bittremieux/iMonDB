package inspector.jmondb.model;

/*
 * #%L
 * jMonDB Core
 * %%
 * Copyright (C) 2014 InSPECtor
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import org.apache.commons.io.FileUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.proxy.HibernateProxyHelper;

import javax.persistence.*;
import java.io.File;
import java.io.IOException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Objects;

/**
 * Represents an event that influenced the mass spectrometer, such as calibrations, maintenance, or unexpected incidents.
 */
@Entity
@Access(AccessType.FIELD)
@Table(name="imon_event", uniqueConstraints=@UniqueConstraint(columnNames={"l_imon_instrument_id", "eventdate"}))
public class Event {

    @Transient
    private static final Logger LOGGER = LogManager.getLogger(Event.class);

    /** read-only iMonDB primary key; generated by JPA */
    @Id
    @Column(name="id", nullable=false)
    @GeneratedValue(strategy= GenerationType.IDENTITY)
    private Long id;

    /** the {@link Instrument} on which the event occurred */
    @ManyToOne(fetch=FetchType.EAGER)
    @JoinColumn(name="l_imon_instrument_id", nullable=false, referencedColumnName="id")
    private Instrument instrument;

    /** the date on which the event occurred */
    @Column(name="eventdate", nullable=false)
    private Timestamp date;
    /** the {@link EventType} */
    @Column(name="type", nullable=false)
    private EventType type;
    /** a description of the observed problem */
    @Column(name="problem", columnDefinition="TEXT")
    private String problem;
    /** a description of the solution undertaken to solve the problem */
    @Column(name="solution", columnDefinition="TEXT")
    private String solution;
    /** additional custom information pertaining to the event */
    @Column(name="extra", columnDefinition="TEXT")
    private String extra;

    /** the attachment file name */
    @Column(name="attachment_name", length=255)
    private String attachmentFileName;
    /** the binary content of the attachment */
    @Lob
    @Column(name="attachment")
    private byte[] attachmentBytes;

    /**
     * Default constructor required by JPA.
     * Protected access modification enforces (limited) class immutability.
     */
    protected Event() {

    }

    /**
     * Creates an {@link Event}.
     *
     * @param instrument  the {@link Instrument} on which the event occurred
     * @param date  the date on which the event occurred
     * @param type  the {@link EventType}
     */
    public Event(Instrument instrument, Timestamp date, EventType type) {
        this();

        setDate(date);
        setType(type);
        setInstrument(instrument);
    }

    /**
     * Creates an {@link Event}.
     *
     * @param instrument  the {@link Instrument} on which the event occurred, not {@code null}
     * @param date  the date on which the event occurred, not {@code null}
     * @param type  the {@link EventType}, not {@code null}
     * @param problem  a description of the observed problem
     * @param solution  a description of the solution undertaken to solve the problem
     * @param extra  additional custom information pertaining to the event
     */
    public Event(Instrument instrument, Timestamp date, EventType type, String problem, String solution, String extra) {
        this(instrument, date, type);
        setProblem(problem);
        setSolution(solution);
        setExtra(extra);
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Instrument getInstrument() {
        return instrument;
    }

    private void setInstrument(Instrument instrument) {
        if(instrument != null) {
            this.instrument = instrument;
            instrument.addEvent(this);
        } else {
            LOGGER.error("The event's instrument is not allowed to be <null>");
            throw new NullPointerException("The event's instrument is not allowed to be <null>");
        }
    }

    public Timestamp getDate() {
        return new Timestamp(date.getTime());
    }

    private void setDate(Timestamp date) {
        if(date != null) {
            this.date = date;
        } else {
            LOGGER.error("The event's date is not allowed to be <null>");
            throw new NullPointerException("The event's date is not allowed to be <null>");
        }
    }

    public EventType getType() {
        return type;
    }

    private void setType(EventType type) {
        if(type != null) {
            this.type = type;
        } else {
            LOGGER.error("The event's type is not allowed to be <null>");
            throw new NullPointerException("The event's type is not allowed to be <null>");
        }
    }

    public String getProblem() {
        return problem;
    }

    public void setProblem(String problem) {
        this.problem = problem;
    }

    public String getSolution() {
        return solution;
    }

    public void setSolution(String solution) {
        this.solution = solution;
    }

    public String getExtra() {
        return extra;
    }

    public void setExtra(String extra) {
        this.extra = extra;
    }

    public String getAttachmentName() {
        return attachmentFileName;
    }

    public byte[] getAttachmentContent() {
        return attachmentBytes != null ? attachmentBytes.clone() : null;
    }

    public void setAttachmentName(String name) {
        attachmentFileName = name;
    }

    public void setAttachmentContent(byte[] content) {
        attachmentBytes = content != null ? content.clone() : null;
    }

    public void setAttachment(File attachment) {
        // add the file content if the file is valid
        if(attachment != null) {
            try {
                setAttachmentName(attachment.getName());
                setAttachmentContent(FileUtils.readFileToByteArray(attachment));
            } catch(IOException e) {
                // reset file content
                attachmentFileName = null;
                attachmentBytes = null;

                LOGGER.warn("Unable to set file <{}> as an attachment", attachment.getName());
                throw new IllegalArgumentException("Unable to set file <" + attachment.getName() +  "> as an attachment", e);
            }
        } else {
            // reset file content
            attachmentFileName = null;
            attachmentBytes = null;
        }
    }

    @Override
    public boolean equals(Object o) {
        if(this == o) {
            return true;
        }
        if(o == null || getClass() != HibernateProxyHelper.getClassWithoutInitializingProxy(o)) {
            return false;
        }

        final Event event = (Event) o;
        return     Objects.equals(instrument, event.getInstrument())
                && Objects.equals(date, event.getDate())
                && Objects.equals(type, event.getType());
    }

    @Override
    public int hashCode() {
        return Objects.hash(instrument, date, type);
    }

    @Override
    public String toString() {
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        return "Event {id=" + id + ", instrument=" + instrument.getName() + ", date=" + sdf.format(date.getTime()) + ", type=" + type.toString() + "}";
    }
}
